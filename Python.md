### 2

```python
print(name.title()) 首字母大写
print(name.upper()) 全部大写
print(name.lower()) 全部小写
```

python中使用‘+’来拼接字符串

在python中尽量使用小写字母，数字和下划线来命名函数，不要使用l和o

python是空格敏感的

要在字符串中添加制表符，可使用字符组合\t 

要在字符串中添加换行符，可使用字符组合\n： 

Python能够找出字符串开头和末尾多余的空白。要确保字符串末尾没有空白，可使用方法rstrip()。 你还可以剔除字符串开头的空白，或同时剔除字符串两端的空白。为此，可分别使用方法lstrip()和strip()： 

str()可将其他类型的变量变为字符串

在Python中，注释用井号（ #）标识。井号后面的内容都会被Python解释器忽略， 编写注释的主要目的是阐述代码要做什么，以及是如何做的。 

> >Python之禅（import this）
> >The Zen of Python, by Tim Peters
>
> Beautiful is better than ugly.
> Explicit is better than implicit.
> Simple is better than complex.
> Complex is better than complicated.
> Flat is better than nested.
> Sparse is better than dense.
> Readability counts.
> Special cases aren't special enough to break the rules.
> Although practicality beats purity.
> Errors should never pass silently.
> Unless explicitly silenced.
> In the face of ambiguity, refuse the temptation to guess.
> There should be one-- and preferably only one --obvious way to do it.
> Although that way may not be obvious at first unless you're Dutch.
> Now is better than never.
> Although never is often better than *right* now.
> If the implementation is hard to explain, it's a bad idea.
> If the implementation is easy to explain, it may be a good idea.
> Namespaces are one honking great idea -- let's do more of those!

### 3

要访问列表元素，可指出列表的名称，再指出元素的索引，并将其放在方括号内。 索引从 0 而不是 1 开始 

Python为访问最后一个列表元素提供了一种特殊语法。通过将索引指定为-1，可让Python返回最后一个列表元素。方法append()将元素'ducati'添加到了列表末尾，为控制用户，可首先创建一个空列表，用于存储用户将要输入的值，然后将用户提供的每个新值附加到列表中。

```
motorcycles.append('ducati')
```

 

使用方法insert()可在列表的任何位置添加新元素。 为此，你需要指定新元素的索引和值。 

```python
 motorcycles.insert(0, 'ducati')
```

del语句可用来删除列表中的元素只需知道索引即可。如del motorcycles[0] 

方法pop()可删除列表末尾的元素，并让你能够接着使用它。术语弹出（ pop）源自这样的类比：列表就像一个栈，而删除列表末尾的元素相当于弹出栈顶元素。 

实际上，你可以使用pop()来删除列表中任何位置的元素，只需在括号中指定要删除的元素的索引即可。 

**如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用del语句；如果你要在删除元素后还能继续使用它，就使用方法pop()。 **

根据值删除元素，你不知道要从列表中删除的值所处的位置。如果你只知道要删除的元素的值，可使
用方法remove()。 

方法remove()只删除第一个指定的值。如果要删除的值可能在列表中出现多次，就需要使用循环来判断是否删除了所有这样的值。 

Python方法sort()让你能够较为轻松地对列表进行排序。 

cars.sort() 

你还可以按与字母顺序相反的顺序排列列表元素，为此，只需向sort()方法传递参数reverse=True。 

cars.sort(reverse=True) 

使用函数 sorted()对列表进行临时排序 ,不改变实际顺序。如果你要按与字母顺序相反的顺序显示列表，也可向函数sorted()传递参数reverse=True。 

要反转列表元素的排列顺序，可使用方法reverse()。 

方法reverse()永久性地修改列表元素的排列顺序，但可随时恢复到原来的排列顺序，为此只需对列表再次调用reverse()即可。 

使用函数len()可快速获悉列表的长度。 



需要对列表中的每个元素都执行相同的操作时，可使用Python中的for循环。 

编写for循环时，对于用于存储列表中每个值的临时变量，可指定任何名称。然而，选择描述单个列表元素的有意义的名称大有帮助。 

Python通过使用缩进让代码更易读；简单地说，它要求你使用缩进让代码整洁而结构清晰。 

### 4

Python函数range()让你能够轻松地生成一系列的数字 。在这个示例中， range()只是打印数字1~4，这是你在编程语言中经常看到的差一行为的结果。函数range()让Python从你指定的第一个值开始数，并在到达你指定的第二个值后停止，因此输出不包含第二个值（这里为5）。 

创建数字列表，可使用函数list()将range()的结果直接转换为列表。 

range(2,11,2)  其中第三个数代表步长

在Python中，两个星号（ **）表示乘方运算。 

> 这三者可直接对数组进行运算
>
> min()
>
> max()
>
> sum()

```python
squares = [value**2 for value in range(1,11)]
```

切片players[0:3] 

数组切片赋值与数组赋值是两种完全不同的情况！

Python将不能修改的值称为不可变的，而不可变的列表被称为元组。 元组看起来犹如列表，但使用圆括号而不是方括号来标识。定义元组后，就可以使用索引来访问其元素，就像访问列表元素一样 。由于试图修改元组的操作是被禁止的，因此Python指出不能给元组的元素赋值。 

虽然不能修改元组的元素，但可以给存储元组的变量赋值。因此，如果要修改前述矩形的尺
寸，可重新定义整个元组。

**PEP 8建议每级缩进都使用四个空格，这既可提高可读性，又留下了足够的多级缩进空间。 **你在编写代码时应该使用制表符键，但一定要对编辑器进行设置，使其在文档中插入空格而不是制表符。 

很多Python程序员都建议每行不超过80字符。 PEP 8还建议
注释的行长都不超过72字符 。要将程序的不同部分分开，可使用空行。你应该使用空行来组织程序文件，但也不能滥用；
只要按本书的示例展示的那样做，就能掌握其中的平衡。 空行不会影响代码的运行，但会影响代码的可读性。 Python解释器根据水平缩进情况来解读代码，但不关心垂直间距。 

[PEP 8]( https://python.org/dev/peps/pep-0008/) 

### 5

每条if语句的核心都是一个值为True或False的表达式，这种表达式被称为条件测试。  

要检查是否两个条件都为True，可使用关键字and将两个条件测试合而为一 

关键字or也能够让你检查多个条件，但只要至少有一个条件满足，就能通过整个测试。仅当
两个测试都没有通过时，使用or的表达式才为False。 

要判断特定的值是否已包含在列表中，可使用关键字in。 

确定特定的值未包含在列表中很重要；在这种情况下，可使用关键字not in。 

if conditional_test:
	do something 

经常需要在条件测试通过了时执行一个操作，并在没有通过时执行另一个操作；在这种情况
下，可使用Python提供的if-else语句。 

经常需要检查超过两个的情形，为此可使用Python提供的if-elif-else结构。 Python只执行
if-elif-else结构中的一个代码块，它依次检查每个条件测试，直到遇到通过了的条件测试。测
试通过后， Python将执行紧跟在它后面的代码，并跳过余下的测试 。可根据需要使用任意数量的elif代码块。

**总之，如果你只想执行一个代码块，就使用if-elif-else结构；如果要运行多个代码块，就
使用一系列独立的if语句。 **

判断条件的语句后面必须交“：”。

在条件测试的格式设置方面， PEP 8提供的唯一建议是，在诸如==、 >=和<=等比较运算符两边各添加一个空格 。

### 6

在Python中， 字典是一系列键—值对。每个键都与一个值相关联，你可以使用键来访问与之相关联的值。与键相关联的值可以是数字、字符串、列表乃至字典。事实上，可将任何Python对象用作字典中的值。 

键—值对是两个相关联的值。指定键时， Python将返回与之相关联的值。键和值之间用冒号分隔，而键—值对之间用逗号分隔。在字典中，你想存储多少个键—值对都可以。 

Python不关心键—值对的添加顺序，而只关心键和值之间的关联关系。 

要修改字典中的值，可依次指定字典名、用方括号括起的键以及与该键相关联的新值。 

对于字典中不再需要的信息，可使用del语句将相应的键—值对彻底删除。 

正如你看到的，我们将一个较大的字典放在了多行中。其中每个键都是一个被调查者的名字，而每个值都是被调查者喜欢的语言。确定需要使用多行来定义字典时，在输入左花括号后按回车键，再在下一行缩进四个空格，指定第一个键—值对，并在它后面加上一个逗号。此后你再次按回车键时，文本编辑器将自动缩进后续键—值对，且缩进量与第一个键—值对相同。
定义好字典后，在最后一个键—值对的下一行添加一个右花括号，并缩进四个空格，使其与字典中的键对齐。另外一种不错的做法是在最后一个键—值对后面也加上逗号，为以后在下一行添加键—值对做好准备。 

在不需要使用字典中的值时，方法keys()很有用。 

如果你感兴趣的主要是字典包含的值，可使用方法values()，它返回一个值列表，而不包含任何键。 

但如果被调查者很多，最终的列表可能包含大量的重复项。为剔除重复项，可使用集合（ set）。集合类似于列表，但每个元素都必须是独一无二的。

字典的存储用大括号，字典中键值的读取用中括号。

### 7.1

函数input()让程序暂停运行，等待用户输入一些文本。获取用户输入后， Python将其存储在
一个变量中，以方便你使用。 

运算符+=在存储在prompt中的字符串末尾附加一个字符串。 

使用函数input()时， Python将用户输入解读为字符串。 

函数int()将数字的字符串表示转换为数值表示。

处理数值信息时， 求模运算符（ %）是一个很有用的工具，它将两个数相除并返回余数 。

> 如果你使用的是Python 2.7，应使用函数raw_input()来提示用户输入。这个函数与Python 3
> 中的input()一样，也将输入解读为字符串。
> Python 2.7也包含函数input()，但它将用户输入解读为Python代码，并尝试运行它们。因此，
> 最好的结果是出现错误，指出Python不明白输入的代码；而最糟的结果是，将运行你原本无意运
> 行的代码。如果你使用的是Python 2.7，请使用raw_input()而不是input()来获取输入。 

for循环用于针对集合中的每个元素都一个代码块，而while循环不断地运行，直到指定的条
件不满足为止。 

在要求很多条件都满足才继续运行的程序中，可定义一个变量，用于判断整个程序是否处于
活动状态。这个变量被称为**标志**，充当了程序的交通信号灯。 

要立即退出while循环，不再运行循环中余下的代码，也不管条件测试的结果如何，可使用
break语句。 

要返回到循环开头，并根据条件测试结果决定是否继续执行循环，可使用continue语句，它
不像break语句那样不再执行余下的代码并退出整个循环。 

**每个程序员都会偶尔因不小心而编写出无限循环，在循环的退出条件比较微妙时尤其如此。
如果程序陷入无限循环，可按Ctrl + C，也可关闭显示程序输出的终端窗口。 **

```python
prompt = "请输入您所需要的披萨配料："
prompt += "\n 当您输入完成后，请按'quit'退出点餐系统\n"
active = True
ingredients = []

print(prompt)
while active == True:
	ingredient = input("我需要在披萨中加入  ")
	if ingredient != 'quit':
		print("您刚才输入了" + ingredient + "确定吗？ ")
		sure = input('\n如果确定，请按“y”  ')
		if sure == 'y':
			ingredients.append(ingredient)
			print(ingredient + "已加入\n")
		else:
			print(ingredient + '将不会被添加进配料表\n')
	else:
		active = False
		
print('您刚才输入的配料如下：\n')

for list in ingredients:
	print(list)
	
print('您的订单正在制作，谢谢光临')
```

```cmd
我需要在披萨中加入  土豆
您刚才输入了土豆确定吗？

如果确定，请按“y”  y
土豆已加入

我需要在披萨中加入  豆腐
您刚才输入了豆腐确定吗？

如果确定，请按“y”  y
豆腐已加入

我需要在披萨中加入  fanqie
您刚才输入了fanqie确定吗？

如果确定，请按“y”  n
fanqie将不会被添加进配料表

我需要在披萨中加入  quit
您刚才输入的配料如下：

肉丝
土豆
豆腐
您的订单正在制作，谢谢光临
ECHO 处于打开状态。
请按任意键继续. . .
```

for循环是一种遍历列表的有效方式，但在for循环中不应修改列表，否则将导致Python难以跟踪其中的元素。 要在遍历列表的同时对其进行修改，可使用while循环。通过将while循环同列表和字典结合起来使用，可收集、存储并组织大量输入，供以后查看和显示。 

### 8

函数是带名字的代码块，用于完成具体的工作。 

紧跟在def greet_user():后面的所有缩进行构成了函数体。  

实参是调用函数时传递给函数的信息。 

向函数传递实参的方式很多，可使用位置实参，这要求实参的顺序与形参的顺序相同；也可使用关键字实参，其中每个实参都由变量名和值组成；还可使用列表和字典。 

关键字实参是传递给函数的名称—值对。你直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆 .

使用关键字实参时，务必准确地指定函数定义中的形参名。 

使用默认值时，在形参列表中必须先列出没有默认值的形参， 

在函数中，可使用return语句将值返回到调用函数的代码行。 

Python将非空字符串解读为True， 

函数可返回任何类型的值，包括列表和字典等较复杂的数据结构 

切片表示法[:]创建列表的副本。 

一个*号创建元组，两个**创建字典。

函数的优点之一是，使用它们可将代码块与主程序分离。通过给函数指定描述性名称，可让
主程序容易理解得多。 

import语句允许在当前运行的程序文件中使用模块中的代码。 

通过将函数存储在独立的文件中，可隐藏程序代码的细节，将重点放在程序的高层逻辑上。 

要让函数是可导入的，得先创建模块。 模块是扩展名为.py的文件，包含要导入到程序中的
代码。 

只需编写一条import语句并在其中指定模块名，就可在程序中使用该
模块中的所有函数。如果你使用这种import语句导入了名为module_name.py的整个模块，就可使用下面的语法来使用其中任何一个函数 .

```python
module_name.function_name()
```

##### 导入特定的函数 

```
from module_name import function_name
from module_name import function_0, function_1, function_2

```

如果要导入的函数的名称可能与程序中现有的名称冲突，或者函数的名称太长，可指定简短而独一无二的别名——函数的另一个名称，类似于外号。要给函数指定这种特殊外号，需要在导入它时这样做。 

给形参指定默认值时，等号两边不要有空格；

对于函数调用中的关键字实参， 等号两边不要有空格。

### 9

面向对象编程是最有效的软件编写方法之一。**在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。**编写类时，你定义一大类对象都有的通用行为。基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。使用面向对象编程可模拟现实情景，其逼真程度达到了令你惊讶的地步。 

根据约定，在Python中，首字母大写的名称指的是类。这个类定义中的括号是空的，因为我们要从空白创建这个类。 

类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式。 3处的方法__init__()是一个特殊的方法，每当你根据Dog类创建新实例时， Python都会自动运行它。***！！！init前后应为双下划线！！！***在这个方法的名称中，开头和末尾各有两个下划线，这是一种约定，旨在避免Python默认方法与普通方法发生名称冲突。 

可通过实例访问的变量称为属性。 

我们通常可以认为首字母大写的名称（如Dog）指的是类，而小写的名称（如my_dog）指的是根据类创建的实例。 

类中的每个属性都必须有初始值，哪怕这个值是0或空字符串。 

可以以三种不同的方式修改属性的值：直接通过实例进行修改；通过方法进行设置；通过方
法进行递增（增加特定的值）。 

创建子类的实例时， Python首先需要完成的任务是给父类的所有属性赋值。为此，子类的方
法__init__()需要父类施以援手。 

创建子类时，父类必须包含在当前文件中，且位于子类前面。 父类也称为超类（ superclass），名称super因此而得名。 

这让你进入了程序员的另一个境界：解决上述问题时，你从较高的逻辑层面（而不是语法层面）考虑；你考虑的不是Python，而是如何使用代码来表示实物。到达这种境界后，你经常会发现，现实世界的建模方法并没有对错之分。有些方法的效率更高，但要找出效率最高的表示法，需要经过一定的实践。只要代码像你希望的那样运行，就说明你做得很好！即便你发现自己不得不多次尝试使用不同的方法来重写类，也不必气馁；要编写出高效、准确的代码，都得经过这样的过程。  

**！！！Python是缩进敏感的语言！！！**

Python标准库是一组模块，安装的Python都包含它。你现在对类的工作原理已有大致的了解，可以开始使用其他程序员编写好的模块了。可使用标准库中的任何函数和类，为此只需在程序开头包含一条简单的import语句。

 字典让你能够将信息关联起来，但它们不记录你添加键—值对的顺序。要创建字典并记录其中的键—值对的添加顺序，可使用模块collections中的OrderedDict类。 OrderedDict实例的行为几乎与字典相同，区别只在于记录了键—值对的添加顺序。 

在python中，每一句代码都应该顶格写

##### 9.6 类编码风格

你必须熟悉有些与类相关的编码风格问题，在你编写的程序较复杂时尤其如此。
类名应采用驼峰命名法，即将类名中的每个单词的首字母都大写，而不使用下划线。实例名和模块名都采用小写格式，并在单词之间加上下划线。
对于每个类，都应紧跟在类定义后面包含一个文档字符串。这种文档字符串简要地描述类的功能，并遵循编写函数的文档字符串时采用的格式约定。每个模块也都应包含一个文档字符串，对其中的类可用于做什么进行描述。
可使用空行来组织代码，但不要滥用。在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。
需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的import语句，再添加一个空行，然后编写导入你自己编写的模块的import语句。在包含多条import语句的程序中，这种做法让人更容易明白程序使用的各个模块都来自何方。 

### 10

在这个程序中，第1行代码做了大量的工作。我们先来看看函数open()。要以任何方式使用文件——哪怕仅仅是打印其内容，都得先打开文件，这样才能访问它。函数open()接受一个参数：要打开的文件的名称。 Python在当前执行的文件所在的目录中查找指定的文件。在这个示例中，当前运行的是file_reader.py，因此Python在file_reader.py所在的目录中查找pi_digits.txt。函数open()返回一个表示文件的对象。在这里， open('pi_digits.txt')返回一个表示文件pi_digits.txt的对象； Python将这个对象存储在我们将在后面使用的变量中。关键字with在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open()，但没有调用close()；你也可以调用open()和close()来打开和关闭文件，但这样做时，如果程序存在bug，导致close()语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close()，你会发现需要使用文件时它已关闭（无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它， Python自会在合适的时候自动将其关闭。
有了表示pi_digits.txt的文件对象后，我们使用方法read()（前述程序的第2行）读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量contents中。这样，通过打印contents的值，就可将这个文本文件的全部内容显示出来 

相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？因为read()到达文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print语句中使用rstrip()： 

Windows系统中，在文件路径中使用反斜杠（ \）而不是斜杠（ /）！ 

可使用方法 replace()将字符串中的特定单词都替换为另一个单词。 

可以使用open()语句写入文本。在这个示例中，调用open()时提供了两个实参（见Ø）。第一个实参也是要打开的文件的名称；第二个实参（ 'w'）告诉Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式（ 'r'）、 写入模式（ 'w'）、 附加模式（ 'a'）或让你能够读取和写入文件的模式（ 'r+'）。如果你省略了模式实参， Python将以默认的只读模式打开文件。
如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（ 'w'）模式打开文件时千万要小心，因为如果指定的文件已经存在， Python将在返回文件对象前清空该文件 在这个示例中，调用open()时提供了两个实参（见Ø）。第一个实参也是要打开的文件的名称；第二个实参（ 'w'）告诉Python，我们要以写入模式打开这个文件。打开文件时，可指定读取模式（ 'r'）、 写入模式（ 'w'）、 附加模式（ 'a'）或让你能够读取和写入文件的模式（ 'r+'）。如果你省略了模式实参， Python将以默认的只读模式打开文件。
**如果你要写入的文件不存在，函数open()将自动创建它。然而，以写入（ 'w'）模式打开文件时千万要小心，因为如果指定的文件已经存在， Python将在返回文件对象前清空该文件。** 

Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str()将其转换为字符串格式。 如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式打开文件。 

**空白在Python中是重要的。事实上行首的空白是重要的。它称为缩进。在逻辑行首的空白（空格和制表符）用来决定逻辑行的缩进层次，从而用来决定语句的分组。**

**这意味着同一层次的语句必须有相同的缩进。每一组这样的语句称为一个块。我们将在后面的章节中看到有关块的用处的例子。**

Python使用被称为异常的特殊对象来管理程序执行期间发生的错误。 如果你编写了处理该异常的代码，程序将继续运行；
如果你未对异常进行处理，程序将停止，并显示一个traceback，其中包含有关异常的报告。 

try-except代码块 的工作机制：如果try代码块中的代码运行起来没有问题， Python将跳过except代码块；如果try代码块中的代码导致了错误， Python将查找这样的except代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。 

程序崩溃可不好，但让用户看到traceback也不是好主意。不懂技术的用户会被它们搞糊涂，而且如果用户怀有恶意，他会通过traceback获悉你不希望他知道的信息。例如，*他将知道你的程序文件的名称，还将看到部分不能正确运行的代码。有时候，训练有素的攻击者可根据这些信息判断出可对你的代码发起什么样的攻击。* 



## try/except介绍

> 与其他语言相同，在python中，try/except语句主要是用于处理程序正常执行过程中出现的一些异常情况，如语法错（python作为脚本语言没有编译的环节，在执行过程中对语法进行检测，出错后发出异常消息）、数据除零错误、从未定义的变量上取值等；而try/finally语句则主要用于在无论是否发生异常情况，都需要执行一些清理工作的场合，如在通信过程中，无论通信是否发生错误，都需要在通信完成或者发生错误时关闭网络连接。尽管**try/except和****try/finally**的作用不同，但是在编程实践中通常可以把它们组合在一起使用try/except/else/finally的形式来实现稳定性和灵活性更好的设计。
>
> 
>
> 默认情况下，在程序段的执行过程中，如果没有提供try/except的处理，脚本文件执行过程中所产生的异常消息会自动发送给程序调用端，如python shell，而python shell对异常消息的默认处理则是终止程序的执行并打印具体的出错信息。这也是在python shell中执行程序错误后所出现的出错打印信息的由来。





 

## try/except格式

```python
python中try/except/else/finally语句的完整格式如下所示：

try:
​     Normal execution block
except A:
​     Exception A handle
except B:
​     Exception B handle
except:
​     Other exception handle
else:
​     if no exception,get here
finally:
​     print("finally")   
```



说明：

正常执行的程序在try下面的Normal execution block执行块中执行，在执行过程中如果发生了异常，则**中断当前在Normal execution block中的执行**，跳转到对应的异常处理块中开始执行；

python**从第一个except X处开始查找**，如果找到了对应的exception类型则进入其提供的exception handle中进行处理，如果没有找到则直接进入except块处进行处理。except块是可选项，如果没有提供，该exception将会被提交给python进行默认处理，处理方式则是**终止应用程序并打印提示信息**；

如果在Normal execution block执行块中执行过程中没有发生任何异常，则在执行完Normal execution block后会进入else执行块中（如果存在的话）执行。

无论是否发生了异常，只要提供了finally语句，以上try/except/else/finally代码块执行的最后一步总是执行finally所对应的代码块。



> 需要注意的是：
>
> 1.在上面所示的完整语句中try/except/else/finally所出现的顺序必须是try-->except X-->except-->else-->finally，即所有的**except必须在else和finally之前**，**else（如果有的话）必须在finally之前**，而**except X必须在except之前**。否则会出现语法错误。
>
> 2.对于上面所展示的try/except完整格式而言，else和finally都是可选的，而不是必须的，但是如果存在的话e**lse必须在finally之前**，**finally**（如果存在的话）**必须在整个语句的最后位置**。
>
> 3.在上面的完整语句中，else语句的存在必须以except X或者except语句为前提，**如果在没有except语句的try block中使用else语句会引发语法错误**。也就是说**else不能与try/finally配合使用**。

4.except的使用要非常小心，慎用。

class AError(Exception):
     """AError---exception"""
     print('AError')

 



```
try:

​     \#raise AError
​     asdas('123')
except AError:
​     print("Get AError")
except:
​     print("exception")     
else:
​     print("else")
finally:
​     print("finally")     
print("hello wolrd")

在上面的代码中，Normal execution block中出现了语法错误，但是由于使用了except语句，该语法错误就被掩盖掉了。因此在使用try/except是最好还是要非常清楚的知道Normal execution block中有可能出现的异常类型以进行针对性的处理。
```

方法split()，它根据一个字符串创建一个单词列表。 方法split()以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。 

用户关闭程序时，你几乎总是要保存他们提供的信息；一种简单的方式是使用模块json来存储数据。 

模块json让你能够将简单的Python数据结构转储到文件中，并在程序再次运行时加载该文件中的数据。你还可以使用json在Python程序之间分享数据。 更重要的是， JSON数据格式并非Python专用的，这让你能够将以JSON格式存储的数据与使用其他编程语言的人分享。 

函数json.dump()接受两个实参：要存储的数据以及可用于存储数据的文件对象。 

代码能够正确地运行，但可做进一步的改进——将代码划分为
一系列完成具体工作的函数。这样的过程被称为重构。重构让代码更清晰、更易于理解、更容易扩展。 

### 11

##### 11.1.1 单元测试和测试用例

Python标准库中的模块unittest提供了代码测试工具。 单元测试用于核实函数的某个方面没有问题； 测试用例是一组单元测试，这些单元测试一起核实函数在各种情形下的行为都符合要求。
良好的测试用例考虑到了函数可能收到的各种输入，包含针对所有这些情形的测试。 全覆盖式测
试用例包含一整套单元测试，涵盖了各种可能的函数使用方式。对于大型项目，要实现全覆盖可
能很难。通常，最初只要针对代码的重要行为编写测试即可，等项目被广泛使用时再考虑全覆盖。 

unittest类最有用的功能之一：一个断言方法。断言方法用来核实得到的结果是否与期望的结果一致。 

